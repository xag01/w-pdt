<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Pomodoro</title>

<style>
:root {
    --work: #e74c3c;
    --short: #27ae60;
    --long: #2980b9;
}

body {
    font-family: system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 60px;
    transition: background-color 0.6s ease;
    background-color: var(--work);
    color: white;
}

h1 { margin-bottom: 20px; }

.timer-container { position: relative; width: 220px; height: 220px; }

svg { transform: rotate(-90deg); }

circle { fill: none; stroke-width: 12; }

#progress-bg { stroke: rgba(255,255,255,0.2); }

#progress-ring {
    stroke: white;
    stroke-linecap: round;
    transition: stroke-dashoffset 1s linear;
}

#timeLabel {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 40px;
}

button { margin: 5px; padding: 8px 16px; font-size: 14px; }

.settings { margin-top: 20px; font-size: 14px; text-align: center; }

/* Dot background container */
.progressBar {
    display: flex;
    gap: 8px;
    margin-top: 20px;
    padding: 10px;
    border-radius: 14px;
    background: rgba(255, 255, 255, 0.18); /* neutral background */
}

.dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: rgba(255,255,255,0.35);
    cursor: pointer;
    transition: transform 0.2s ease, background 0.2s ease;
}

.dot.work { background: rgba(231, 76, 60, 0.8); }
.dot.short { background: rgba(39, 174, 96, 0.8); }
.dot.long { background: rgba(41, 128, 185, 0.8); }

/* Reduced outline */
.dot.active {
    transform: scale(1.25);
    box-shadow: 0 0 0 2px rgba(255,255,255,0.22);
}
</style>
</head>

<body>

<h1 id="mode">Work</h1>

<div class="timer-container">
    <svg width="220" height="220">
        <circle id="progress-bg" cx="110" cy="110" r="90"></circle>
        <circle id="progress-ring" cx="110" cy="110" r="90"></circle>
    </svg>
    <div id="timeLabel">25:00</div>
</div>

<div>
    <button id="startPauseBtn" onclick="handleUserAction(toggleTimer)">Start</button>
    <button onclick="handleUserAction(skipSession)">Skip</button>
    <button onclick="handleUserAction(resetTimer)">Reset</button>
</div>

<div class="progressBar" id="progressBar"></div>

<div class="settings">
    <div>
        Work
        <input id="workMin" type="number" min="0" value="25"> min
        <input id="workSec" type="number" min="0" max="59" value="0"> sec
    </div>
    <div>
        Short
        <input id="shortMin" type="number" min="0" value="5"> min
        <input id="shortSec" type="number" min="0" max="59" value="0"> sec
    </div>
    <div>
        Long
        <input id="longMin" type="number" min="0" value="15"> min
        <input id="longSec" type="number" min="0" max="59" value="0"> sec
    </div>
    <div>
        Sessions before long
        <input id="intervalInput" type="number" min="1" value="4">
    </div>

    <div>
        <label>
            <input id="autoStart" type="checkbox"> Auto start next session
        </label>
    </div>

    <div>
        <label>
            Sound:
            <select id="soundPreset">
                <option value="none">No Sound</option>
                <option value="classic">Classic Bell</option>
                <option value="chime">Chime</option>
                <option value="beep">Beep</option>
            </select>
        </label>
    </div>

    <div>
        <label>
            <input id="notifToggle" type="checkbox" checked> Notifications
        </label>
    </div>

    <button onclick="handleUserAction(saveSettings)">Save</button>
</div>

<script>
let timerInterval = null;
let timeRemaining = 0;
let totalTime = 0;
let isRunning = false;

let currentMode = "work";
let workSessionsCompleted = 0;

const ring = document.getElementById("progress-ring");
const radius = 90;
const circumference = 2 * Math.PI * radius;

ring.style.strokeDasharray = circumference;
ring.style.strokeDashoffset = 0;

const mode = document.getElementById("mode");
const startPauseBtn = document.getElementById("startPauseBtn");

const workMin = document.getElementById("workMin");
const workSec = document.getElementById("workSec");
const shortMin = document.getElementById("shortMin");
const shortSec = document.getElementById("shortSec");
const longMin = document.getElementById("longMin");
const longSec = document.getElementById("longSec");
const intervalInput = document.getElementById("intervalInput");

const autoStart = document.getElementById("autoStart");
const notifToggle = document.getElementById("notifToggle");
const soundPreset = document.getElementById("soundPreset");

const progressBar = document.getElementById("progressBar");

// ------------------
// AUDIO SETUP (WebAudio for reliable playback)
// ------------------
let audioCtx = null;
function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}

function playTone(freq, duration = 0.15) {
    initAudio(); // ALWAYS try to init

    if (!audioCtx) return;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.frequency.value = freq;
    osc.type = "sine";

    gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);

    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + duration);
}

function handleUserAction(action) {
    initAudio();
    action();
}

// ------------------
// SANITIZE INPUT
// ------------------
function safeNumber(val, fallback = 0) {
    const num = Number(val);
    return Number.isFinite(num) ? num : fallback;
}

function getSettings() {
    const work = (safeNumber(workMin.value, 25) * 60) + safeNumber(workSec.value, 0);
    const short = (safeNumber(shortMin.value, 5) * 60) + safeNumber(shortSec.value, 0);
    const long = (safeNumber(longMin.value, 15) * 60) + safeNumber(longSec.value, 0);
    const interval = Math.max(1, safeNumber(intervalInput.value, 4));

    return {
        work,
        short,
        long,
        interval,
        autoStart: autoStart.checked,
        soundPreset: soundPreset.value,
        notifications: notifToggle.checked
    };
}

function loadSettings() {
    const saved = JSON.parse(localStorage.getItem("pomodoroSettings"));
    if (saved) {
        workMin.value = Math.floor(saved.work / 60);
        workSec.value = saved.work % 60;

        shortMin.value = Math.floor(saved.short / 60);
        shortSec.value = saved.short % 60;

        longMin.value = Math.floor(saved.long / 60);
        longSec.value = saved.long % 60;

        intervalInput.value = saved.interval;
        autoStart.checked = saved.autoStart;
        soundPreset.value = saved.soundPreset;
        notifToggle.checked = saved.notifications;
    }

    currentMode = "work";
    workSessionsCompleted = 0;
    setTimeForMode();
    renderProgressBar();
}

function saveSettings() {
    localStorage.setItem("pomodoroSettings", JSON.stringify(getSettings()));
    resetToStart();
}

// ------------------
// THEME + TIME
// ------------------
function setTheme() {
    const root = document.documentElement;
    const body = document.body;

    if (currentMode === "work") {
        body.style.backgroundColor = getComputedStyle(root).getPropertyValue("--work");
    } else if (currentMode === "short") {
        body.style.backgroundColor = getComputedStyle(root).getPropertyValue("--short");
    } else {
        body.style.backgroundColor = getComputedStyle(root).getPropertyValue("--long");
    }
}

function setTimeForMode() {
    const settings = getSettings();

    if (currentMode === "work") {
        timeRemaining = settings.work;
        mode.textContent = "Work";
    } else if (currentMode === "short") {
        timeRemaining = settings.short;
        mode.textContent = "Short Break";
    } else {
        timeRemaining = settings.long;
        mode.textContent = "Long Break";
    }

    totalTime = timeRemaining;
    setTheme();
    updateDisplay();
}

// ------------------
// DISPLAY
// ------------------
function updateDisplay() {
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;

    const formatted =
        `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;

    document.getElementById("timeLabel").textContent = formatted;
    document.title = formatted + " - " + mode.textContent;

    if (totalTime > 0) {
        const progress = timeRemaining / totalTime;
        ring.style.strokeDashoffset = circumference * (1 - progress);
    }
}

// ------------------
// TIMER CONTROLS
// ------------------
function toggleTimer() {
    if (isRunning) pauseTimer();
    else startTimer();
}

function startTimer() {
    if (isRunning) return;
    isRunning = true;
    startPauseBtn.textContent = "Pause";

    timerInterval = setInterval(() => {
        if (timeRemaining > 0) {
            timeRemaining--;
            updateDisplay();
        } else {
            pauseTimer();
            nextSession(true);
        }
    }, 1000);
}

function pauseTimer() {
    isRunning = false;
    startPauseBtn.textContent = "Start";
    clearInterval(timerInterval);
}

function resetTimer() {
    pauseTimer();
    setTimeForMode();
    renderProgressBar();
}

function resetToStart() {
    pauseTimer();
    currentMode = "work";
    workSessionsCompleted = 0;
    setTimeForMode();
    renderProgressBar();
}

function skipSession() {
    pauseTimer();
    nextSession(false);
}

// ------------------
// NEXT SESSION + PROGRESS
// ------------------
function nextSession(endedNaturally = true) {
    const settings = getSettings();
    let nextMode;

    if (currentMode === "work") {
        workSessionsCompleted++;

        // Now we correctly handle the long break
        if (workSessionsCompleted === settings.interval) {
            nextMode = "long";
        } else {
            nextMode = "short";
        }
    } else {
        // After short or long break -> back to work
        if (currentMode === "long") {
            workSessionsCompleted = 0; // reset cycle after long break
        }
        nextMode = "work";
    }

    if (endedNaturally) {
        playModeSound(nextMode);
    }

    currentMode = nextMode;
    setTimeForMode();
    renderProgressBar();

    if (notifToggle.checked) notifyUser();
    if (autoStart.checked) startTimer();
}

function playModeSound(mode) {
    const preset = soundPreset.value;

    if (preset === "none") return;

    if (preset === "classic") {
        if (mode === "work") playTone(600, 0.25);
        else if (mode === "short") playTone(900, 0.15);
        else playTone(500, 0.35);
    } else if (preset === "chime") {
        if (mode === "work") playTone(1000, 0.2);
        else if (mode === "short") playTone(1200, 0.12);
        else playTone(800, 0.3);
    } else if (preset === "beep") {
        if (mode === "work") playTone(700, 0.1);
        else if (mode === "short") playTone(900, 0.08);
        else playTone(600, 0.12);
    }
}

// ------------------
// NOTIFICATIONS
// ------------------
function notifyUser() {
    if ("Notification" in window && Notification.permission === "granted") {
        new Notification(mode.textContent + " started");
    }
}

if ("Notification" in window) {
    Notification.requestPermission();
}

// ------------------
// PROGRESS BAR (Clickable)
// ------------------
function buildCycle() {
    const settings = getSettings();
    const steps = [];

    for (let i = 0; i < settings.interval; i++) {
        steps.push("work");
        steps.push(i === settings.interval - 1 ? "long" : "short");
    }

    return steps;
}

function renderProgressBar() {
    const steps = buildCycle();
    progressBar.innerHTML = "";

    let index;
    if (currentMode === "work") {
        index = workSessionsCompleted * 2;
    } else {
        index = (workSessionsCompleted * 2) - 1;
    }
    index = Math.max(0, Math.min(index, steps.length - 1));

    steps.forEach((step, i) => {
        const dot = document.createElement("div");
        dot.classList.add("dot", step);
        if (i === index) dot.classList.add("active");

        dot.onclick = () => {
            pauseTimer();
            jumpToIndex(i);
        };

        progressBar.appendChild(dot);
    });
}

function jumpToIndex(index) {
    const steps = buildCycle();

    if (index < 0 || index >= steps.length) return;

    const stepMode = steps[index];

    if (stepMode === "work") {
        workSessionsCompleted = Math.floor(index / 2);
    } else {
        workSessionsCompleted = Math.floor((index + 1) / 2);
    }

    currentMode = stepMode;
    setTimeForMode();
    renderProgressBar();
}

loadSettings();
</script>

</body>
</html>
